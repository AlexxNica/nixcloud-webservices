{ config, pkgs, lib, ... } @ args:

with lib;

let
  cfg = config.nixcloud.reverse-proxy;
  stateDir = "/var/lib/nixcloud/reverse-proxy";
  user = "reverse-proxy";
  group = "reverse-proxy";
  mkBasicAuth = authDef: let
    htpasswdFile = pkgs.writeText "basicAuth.htpasswd" (
      concatStringsSep "\n" (mapAttrsToList (user: password: ''
        ${user}:{PLAIN}${password}
      '') authDef)
    );
  in ''
    auth_basic secured;
    auth_basic_user_file ${htpasswdFile};
  '';

in

{
  options = {
    nixcloud.reverse-proxy = {
      enable = mkEnableOption "reverse-proxy";

      httpPort = mkOption {
        type = types.int;
        default = 80;
        description = ''port where the reverse proxy listens for incoming http requests'';
      };
      httpsPort = mkOption {
        type = types.int;
        default = 443;
        description = ''port where the reverse proxy listens for incoming https requests'';
      };
      extendEtcHosts = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Write all configured domains into /etc/hosts using networking.extraHosts.
        '';
      };
      extraConfig = mkOption {
        type = types.lines;
        default = "";
        description = ''
          Cnfiguration lines appended to the generated nixcloud reverse-proxy
          configuration file nginx-reverse-proxy.conf.
        '';
      };
      configFile = mkOption {
        type = types.nullOr types.path;
        default = null;
        description = ''
          The path to a configuration which can be used instead the generated one. If the `configFile` option is used most other options are completely ignored.
          This option exists because on nixcloud.io we need to generate the configuration file externally since we can't run `nixos-rebuild switch`.
        ''; #'
      };
      extraMappings = mkOption {
        type = types.listOf (types.submodule (import ./options.nix));
        default = [];
        example = ''
          [{
              port   = 3333;
              path   = "/tour";
              domain = "nixcloud.io";
              ip = "127.0.0.1";
          }];
        '';
        description = ''
          Can be used to append proxy-mappings, created manually, for services not supporting `proxyOptions` in `nixcloud` namespace.
        '';
      };
    };
  };

  config = let
    # call it with: checkAndFormatNginxConfigfile (generateNginxConfigFile f (unique (map (el: el.domain) f)));
    generateNginxConfigFile = allProxyOptions: allDomains: pkgs.writeText "nginx-reverse-proxy.conf" ''
      # this file is auto-generated by the reverse-proxy.nix service
      user "reverse-proxy" "reverse-proxy";
      error_log stderr;

      daemon off;

      events {}
      http {
        ${createServerRecords allProxyOptions allDomains}
        ${cfg.extraConfig}
      }
    '';

    # walk through all services.nixcloud services, collect proxyOptions from enabled services
    # { house = { ... }; music = { ... }; test = { ... }; test1 = { ... }; }
    allNixcloudServicesSet = s: fold (el: con: con // s.${el} ) {} (attrNames s);
    collectedConfigs = allNixcloudServicesSet config.nixcloud.webservices;
    filteredCollectedConfigs = filterAttrs (n: v: v.enable == true) collectedConfigs;
    filteredCollectedConfigsList = fold (el: c: c ++ [ filteredCollectedConfigs.${el}.proxyOptions ]) [] (attrNames filteredCollectedConfigs);

    allProxyOptions = filteredCollectedConfigsList ++ cfg.extraMappings;

    # 1. create a unique list of all domains
    allDomains = unique (map (el: el.domain) allProxyOptions);

    # 2. ACME/TLS details
    #   example value: { "lastlog.de" = "ACME"; "nixcloud.io = "ACME"; }
    #
    # it returns either:
    # - "ACME" if all locations per domain (in proxyOption) have set TLS="ACME" (default)
    # - an assertion on contradicting proxyOptions records

    ACMEsupportSet = fold (el: c:
      if (el.https.mode != "off" && el.TLS != "ACME" && c ? "${el.domain}") then
        let
          a=c.${el.domain};
          b="${el.TLS}";
        in
          if (a == b) then
            c else abort "error: `${a}` != `${b}`! A conflict in `proxyOptions` for for domain ${el.domain}:${toString el.port}${el.path} with a record for the same domain added previously."
      else
        c // { "${el.domain}" = "${el.TLS}"; }
    ) {} allProxyOptions;

    createLocationRecords = mode: filteredProxyOptions:
      lib.concatMapStringsSep "\n" (location: (createLocationRecord mode location)) filteredProxyOptions;

    createLocationRecord = mode: location:
      let
        m = location.${mode}.mode;
        b = location.${mode}.basicAuth;
        r = location.${mode}.record;
        l = builtins.toPath (location.path);
      in
        (if (m == "on") then
          ''
            location ${l} {
            ${if r == "" then ''
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
              proxy_pass http://${location.ip}:${toString location.port}${removeSuffix "/" (toString (builtins.toPath (location.path)))};
            '' else r
            }
              ${if (b != {}) then mkBasicAuth b else ""}
            }
          ''
        else if (m == "redirect_to_http" ) then
          ''
            location ${l} {
              rewrite     ^   http://$server_name$request_uri? permanent;
            }
          ''
        else if (m == "redirect_to_https" ) then
          ''
            location ${l} {
              rewrite     ^   https://$server_name$request_uri? permanent;
            }
          ''
        else abort "unknown location mode: `${m}`, this should never happen.... but just in case!") +
        lib.concatMapStringsSep "\n" (websocket: createWsPaths m mode location location.websockets.${websocket}) (attrNames location.websockets);

    createWsPaths = m: mode: location: websocket:
      let
        b = websocket.${mode}.basicAuth;
        r = websocket.${mode}.record;
        ppp = removeSuffix "/" (toString (builtins.toPath (location.path + websocket.subpath)));
      in
        if (m == "on") then
          ''
            location ${ppp} {
            ${if r == "" then ''
              proxy_http_version 1.1;
              proxy_set_header Upgrade $http_upgrade;
              proxy_set_header Connection "upgrade";
              proxy_pass http://${location.ip}:${toString location.port}${removeSuffix "/" (toString (builtins.toPath (location.path)))};
            '' else r
            }
            
              ${if (b != {}) then mkBasicAuth b else ""}
            }
          ''
        else if (m == "redirect_to_http") then
          ''
            location ${ppp} {
              # FIXME: code below should either be created or also be a redirect but i don't know yet how to do a WS redirect in nginx (qknight)
              # FIXME: this code is likely broken and absolutely untested!
              rewrite     ^   https://$server_name$request_uri? permanent;
            }
          ''
        else if (m == "redirect_to_https") then
          ''
            location ${ppp} {
              # FIXME: code below should either be created or also be a redirect but i don't know yet how to do a WS redirect in nginx (qknight)
              # FIXME: this code is likely broken and absolutely untested!
              rewrite     ^   https://$server_name$request_uri? permanent;
            }
          ''
        else abort "unknown location mode: `${m}`, this should never happen.... but just in case!";

    # 3. map over these and create server (http/https) records per domain
    createServerRecords = allProxyOptions: allDomains:
                          concatMapStringsSep "\n" (createHttpServerRecord  allProxyOptions) allDomains + "\n" +
                          concatMapStringsSep "\n" (createHttpsServerRecord allProxyOptions) allDomains;

    createHttpServerRecord = allProxyOptions: domain:
    let
      filteredProxyOptions = filter (e: e.domain == "${domain}" && e.http.mode != "off") allProxyOptions;
    in ''
      server {
        listen ${toString cfg.httpPort};
        #listen [::]:${toString cfg.httpPort} ipv6only=on;

        server_name ${domain};

        ${optionalString (ACMEsupportSet.${domain} == "ACME") ''
          # code for ACME: ACME will only work with http and not over https (qknight)
          location /.well-known/acme-challenge {
            root /var/lib/acme/acme-challenge;
            auth_basic off;
          }
        ''
        }
        ${createLocationRecords "http" filteredProxyOptions}
      }
    '';

    createHttpsServerRecord = allProxyOptions: domain:
    let
      domainOptions = fold (el: con: if (el.domain == domain && el.https.mode != "off") then con ++ [ el ] else con) [] allProxyOptions;
      needsHttps = fold (el: con: if (el.https.mode != "off") then true else con) false domainOptions;
    in optionalString (domainOptions != [] && needsHttps) ''
      server {
        ssl on;
        listen ${toString cfg.httpsPort} ssl;
        #listen [::]:${toString cfg.httpsPort} ssl ipv6only=on;

        server_name ${domain};  

        ${optionalString (ACMEsupportSet.${domain} == "ACME") ''
        ssl_certificate /var/lib/acme/${domain}/fullchain.pem;
        ssl_certificate_key /var/lib/acme/${domain}/key.pem;
        ''}
        ${createLocationRecords "https" domainOptions}
      }
    '';
    checkAndFormatNginxConfigfile = (import ../../web/backends/lib/nginx_check_config.nix {inherit lib pkgs;}).checkAndFormatNginxConfigfile;
    configFile = generateNginxConfigFile allProxyOptions allDomains;

  in mkIf (cfg.enable) {
    networking.extraHosts = if cfg.extendEtcHosts then lib.concatMapStringsSep "\n" (x: "127.0.0.1 ${x}") allDomains else "";
    
    systemd.services.reverse-proxy = let
      acmeIsUsed = fold (el: con: (el == "ACME") || con) false (attrValues ACMEsupportSet);
    in {
      description   = "reverse-proxy service";
      wantedBy      = [ "multi-user.target" ];
      
      after = if acmeIsUsed then [ "acme-selfsigned-certificates.target" ] else [ "network.target" ];
      wants =  if acmeIsUsed then [ "acme-selfsigned-certificates.target" "acme-certificates.target" ] else [];
      
      stopIfChanged = false;

      preStart = ''
        mkdir -p ${stateDir}/nginx/logs
        mkdir -p ${stateDir}/nginx
        chmod 700 ${stateDir}
        chown -R ${user}:${group} ${stateDir}
      '';
      serviceConfig = {
        ExecStart = "${pkgs.nginx}/bin/nginx -c ${if (cfg.configFile == null) then (checkAndFormatNginxConfigfile {inherit configFile; fileName = "nginx-reverse-proxy.conf";}) else cfg.configFile}/nginx-reverse-proxy.conf -p ${stateDir}/nginx";
        ExecReload = "${pkgs.coreutils}/bin/kill -HUP $MAINPID";
        Restart = "always";
        RestartSec = "10s";
        StartLimitInterval = "1min";
      };
    };

    users.extraUsers = (singleton
      { name = "${user}";
        group = "${group}";
      });

    users.extraGroups = (singleton
      { name = "${user}";
      });

    security.acme.certs = (fold (el: con: if ((ACMEsupportSet.${el}) != "ACME") then con else con // {
      "${el}" = {
        user = user;
        group = group;
        webroot = "/var/lib/acme/acme-challenge";
        postRun = ''
          systemctl reload reverse-proxy
        '';
      };
    }) {} (attrNames ACMEsupportSet));

    nixcloud.tests.wanted = [ "reverse-proxy" ];
  };
}
